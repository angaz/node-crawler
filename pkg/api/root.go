package api

import (
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/a-h/templ"
	"github.com/ethereum/go-ethereum/log"
	"github.com/ethereum/node-crawler/pkg/database"
	"github.com/ethereum/node-crawler/public"
)

func (a *API) handleRoot(w http.ResponseWriter, r *http.Request) {
	networkIDStr := r.URL.Query().Get("network")
	syncedStr := r.URL.Query().Get("synced")
	nextForkStr := r.URL.Query().Get("next-fork")

	networkID, found := parseNetworkID(w, networkIDStr)
	if !found {
		return
	}

	synced, found := parseSyncedParam(w, syncedStr)
	if !found {
		return
	}

	nextFork, found := parseNextForkParam(w, nextForkStr)
	if !found {
		return
	}

	params := fmt.Sprintf("%d,%d,%d", networkID, synced, nextFork)

	b, found := a.getCache(params)
	if found {
		_, _ = w.Write(b)

		return
	}

	fork, forkFound := database.Forks[networkID]

	days := 7

	// All network ids has so much data, so we're prioritizing speed over days
	// of data.
	if networkID == -1 || synced == -1 {
		days = 1
	}

	before := time.Now().Truncate(30 * time.Minute).Add(30 * time.Minute)
	after := before.AddDate(0, 0, -days)

	n := time.Now()

	allStats, err := a.db.GetStats(r.Context(), after, before, networkID, synced)
	if err != nil {
		log.Error("GetStats failed", "err", err)

		w.WriteHeader(http.StatusInternalServerError)
		_, _ = fmt.Fprint(w, "Internal Server Error")

		return
	}

	log.Info("db done", "duration", time.Since(n))

	allStats = allStats.Filter(
		func(_ int, s database.Stats) bool {
			return synced == -1 ||
				(synced == 1 && s.Synced) ||
				(synced == 0 && !s.Synced)
		},
		func(_ int, s database.Stats) bool {
			if networkID == -1 {
				return true
			}

			if s.NetworkID == nil || s.ForkID == nil {
				return false
			}

			if *s.NetworkID != networkID {
				return false
			}

			// If fork is not known, keep the stats.
			if !forkFound {
				return true
			}

			// If the fork is known, the fork ID should be in the set.
			_, found = fork.Hash[*s.ForkID]
			return found
		},
		func(_ int, s database.Stats) bool {
			if nextFork == -1 {
				return true
			}

			if s.NextForkID == nil {
				return false
			}

			// Unknown chain, keep the stats.
			if !forkFound {
				return true
			}

			// Fork time unknown, keep the stats.
			if fork.NextFork == nil {
				return true
			}

			isReady := *s.NextForkID == *fork.NextFork

			return isReady == (nextFork == 1)
		},
	)
	log.Info("filter", "duration", time.Since(n))

	reqURL := public.URLFromReq(r)

	clientNames := allStats.CountClientName()
	countries := allStats.GroupCountries()
	OSs := allStats.GroupOS()
	dialSuccess := allStats.GroupDialSuccess()

	log.Info("group", "duration", time.Since(n))

	statsPage := public.Stats(
		reqURL,
		networkID,
		synced,
		nextFork,
		[]templ.Component{
			public.StatsGraph(
				fmt.Sprintf("Client Names (%dd)", days),
				"client_names",
				clientNames.Timeseries().Percentage(),
			),
			public.StatsGraph(
				fmt.Sprintf("Dial Success (%dd)", days),
				"dial_success",
				dialSuccess.Timeseries().Percentage().Colours("#05c091", "#ff6e76"),
			),
		},
		[]templ.Component{
			public.StatsGroup("Client Names", clientNames.Last()),
			public.StatsGroup("Countries", countries.Last()),
			public.StatsGroup("OS / Archetectures", OSs.Last()),
		},
		len(clientNames) == 0,
	)

	log.Info("page", "duration", time.Since(n))

	index := public.Index(reqURL, statsPage, networkID, synced)

	sb := new(strings.Builder)
	_ = index.Render(r.Context(), sb)

	out := strings.ReplaceAll(sb.String(), "STYLE_REPLACE", "style")

	_, _ = w.Write([]byte(out))

	// Cache the result until 1 minute after the end timestamp.
	// The new stats should have been generated by then.
	a.setCache(params, []byte(out), before.Add(time.Minute))
}
